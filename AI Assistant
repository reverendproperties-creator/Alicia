import React, { useState, useEffect, useCallback, useRef, useMemo } from 'react';
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'firebase/auth';
import { initializeApp } from 'firebase/app';
import { getFirestore, doc, setDoc, collection, query, onSnapshot, serverTimestamp, deleteDoc, getDocs, addDoc } from 'firebase/firestore';
import { 
    Send, Volume2, Loader2, Zap, Search, CornerDownLeft, Image as ImageIcon, X, FileText, Settings, Trash2, 
    ArrowLeft, RotateCcw, Calculator, User, MessageSquare, Save, Edit, BookOpen, Heart, ThumbsUp, ThumbsDown
} from 'lucide-react';

// --- CONFIGURATION & CONSTANTS ---
const API_TEXT_MODEL = 'gemini-2.5-flash-preview-09-2025';
const API_TTS_MODEL = 'gemini-2.5-flash-preview-tts';
const API_KEY = "";
const DEFAULT_PERSONA_NAME = 'Helpful Assistant';
const DEFAULT_PERSONA = {
    name: DEFAULT_PERSONA_NAME,
    role: 'General Purpose AI',
    expertise: 'General Knowledge, Communication, Problem Solving',
    tone: 3, // 1-5 (Neutral)
    formality: 3, // 1-5 (Professional)
    depth: 4, // 1-5 (Expert/Detailed)
    empathyScore: 5, // NEW: 0 (Low Empathy) to 10 (High Empathy)
    constraints: 'Keep responses concise. Your primary function is to assist the user effectively.',
    goal: 'Be a helpful, concise, and friendly AI Assistant.',
};

// Available TTS Voices
const VOICE_OPTIONS = [
    { name: 'Kore (Firm)', value: 'Kore' },
    { name: 'Puck (Upbeat)', value: 'Puck' },
    { name: 'Charon (Informative)', value: 'Charon' },
    { name: 'Leda (Youthful)', value: 'Leda' },
];
const DEFAULT_VOICE = VOICE_OPTIONS[0].value;

// Global variables provided by the environment
const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

// Helper to determine the Firestore collection paths
const getConversationPath = (userId) => `artifacts/${appId}/users/${userId}/conversations`;
const getNotesCollectionPath = (userId) => `artifacts/${appId}/users/${userId}/notes`; 
const getPersonasCollectionPath = (userId) => `artifacts/${appId}/users/${userId}/personas`;

// Helper to check if a string is valid JSON
const isJsonString = (str) => {
    if (typeof str !== 'string' || !str.trim()) return false;
    try {
        JSON.parse(str);
    } catch (e) {
        return false;
    }
    return true;
}

// --- Persona Utility Functions ---
/** Maps a slider value (1-5) to a descriptive word for System Instruction generation. */
const mapSliderToWord = (value, attribute) => {
    const v = parseInt(value, 10);
    switch (attribute) {
        case 'tone':
            return ['Neutral', 'Friendly', 'Enthusiastic', 'Witty', 'Formal'][v - 1] || 'Neutral';
        case 'formality':
            return ['Casual', 'Semi-Formal', 'Professional', 'Academic', 'Strictly Formal'][v - 1] || 'Professional';
        case 'depth':
            return ['Surface Level', 'Detailed', 'Analytical', 'Expert', 'Encyclopedic'][v - 1] || 'Detailed';
        default:
            return '';
    }
};

/** Generates the complete System Instruction string from a persona object. */
const generateSystemInstruction = (persona) => {
    const { name, role, expertise, tone, formality, depth, empathyScore, constraints, goal } = persona;
    
    const descriptiveTone = mapSliderToWord(tone, 'tone');
    const descriptiveFormality = mapSliderToWord(formality, 'formality');
    const descriptiveDepth = mapSliderToWord(depth, 'depth');

    // --- NEW Empathy Logic based on Empathy Score ---
    let empathyDirective = '';
    let empathyDescription = '';

    if (empathyScore >= 8) {
        empathyDirective = 'Always prioritize emotional validation, use supportive and understanding language, and actively acknowledge the userâ€™s feelings before providing information. Use empathetic phrases like "I hear you," or "That sounds challenging."';
        empathyDescription = 'Exceptional';
    } else if (empathyScore >= 5) {
        empathyDirective = 'Maintain a supportive and mindful communication style. Offer brief validation when emotional context is clear. Show basic understanding.';
        empathyDescription = 'Moderate';
    } else if (empathyScore >= 2) {
        empathyDirective = 'Acknowledge emotional tone minimally, but keep the focus primarily on information and problem-solving.';
        empathyDescription = 'Low';
    } else { // 0 or 1
        empathyDirective = 'Keep communication direct and professional, focusing strictly on information delivery and functional responses. Avoid emotional language.';
        empathyDescription = 'Strictly Functional';
    }
    // --- END NEW Empathy Logic ---


    return `
You are an AI Persona named "${name}".
Your core identity is that of a ${role}.

--- Core Directives ---
1. **Primary Goal:** ${goal}
2. **Knowledge Base:** You are highly knowledgeable in the following domains: ${expertise}.
3. **Tone and Style:** Your communication must adhere to the following stylistic parameters:
    - **Tone:** ${descriptiveTone}
    - **Formality:** ${descriptiveFormality}
    - **Depth of Response:** Provide ${descriptiveDepth} answers.

--- Empathy and Emotional Intelligence Directive (Learning Score: ${empathyScore}/10 - ${empathyDescription}) ---
${empathyDirective}

--- Behavioral Constraints ---
${constraints || 'No specific behavioral constraints defined.'}
`.trim();
};

/** * Analyzes the response and the active persona to create a dynamic TTS style prompt. 
 * This adds "naturalness" and "organic" variation to the AI's speech.
 */
const getTtsStylePrompt = (responseText, activePersona) => {
    // Check for explicit emotional content based on keywords
    if (/(great|wonderful|fantastic|excellent|love|happy|cheerfully|amazing|perfect)/i.test(responseText)) {
        return "Say enthusiastically and with a friendly cadence: ";
    }
    // Check for serious/formal/complex topics
    if (/(financial|report|analysis|policy|formally|confirm|critical|data|system|protocol)/i.test(responseText)) {
        return "Respond in a serious and formal tone with a deliberate pace: ";
    }
    // Check for questions or advice
    if (/[?]$/.test(responseText.trim())) {
        return "Say with an inquisitive and helpful tone: ";
    }
    // Check for apologies or negative phrasing
    if (/(sorry|apologize|couldn't find|error|failure)/i.test(responseText)) {
        return "Say with a slightly apologetic tone: ";
    }
    
    // Default based on persona's tone (Tone slider: 1-5)
    // 5 (Witty/Formal) -> More composed/sharp delivery
    if (activePersona.tone >= 4) {
        return "Say with a friendly and engaged tone: ";
    }
    // 1 (Neutral/Slightly bored) -> Very measured delivery
    if (activePersona.tone <= 2) {
        return "Say in a measured and composed tone: ";
    }
    
    // Default neutral instruction
    return "Say clearly and conversationally: ";
};


// --- Function Calling Tool Definition ---
const calculate = (expression) => {
    try {
        if (!/^[0-9+\-*/().\s^]+$/.test(expression)) {
            return "Error: Expression contains unsupported characters or functions.";
        }
        let safeExpression = expression.replace(/\^/g, '**');
        const result = new Function('return ' + safeExpression)();
        if (isNaN(result) || !isFinite(result)) {
            return "Error: Invalid calculation result.";
        }
        return result.toString();
    } catch (e) {
        return "Error: Could not evaluate expression.";
    }
};

const CALCULATOR_TOOL_SCHEMA = {
    functionDeclarations: [{
        name: 'calculate',
        description: 'A simple calculator tool for evaluating complex mathematical expressions. Use this for all arithmetic, percentages, powers, and roots.',
        parameters: {
            type: 'OBJECT',
            properties: {
                expression: { type: 'STRING', description: 'The mathematical expression to evaluate, e.g., "4 + (2 * 5)".' },
            },
            required: ['expression']
        }
    }]
};

// --- Image to Base64 Utility ---
const fileToBase64 = (file) => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result.split(',')[1]); 
    reader.onerror = (error) => reject(error);
    reader.readAsDataURL(file);
  });
};

// --- PCM to WAV Conversion Utilities (essential for TTS) ---
const base64ToArrayBuffer = (base64) => {
  const binaryString = window.atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
};

const pcmToWav = (pcm16, sampleRate) => {
  const numChannels = 1;
  const bitsPerSample = 16;
  const byteRate = (sampleRate * numChannels * bitsPerSample) / 8;
  const blockAlign = (numChannels * bitsPerSample) / 8;
  const dataSize = pcm16.length * 2;
  const buffer = new ArrayBuffer(44 + dataSize);
  const view = new DataView(buffer);
  let offset = 0;

  const writeString = (s) => {
    for (let i = 0; i < s.length; i++) {
      view.setUint8(offset++, s.charCodeAt(i));
    }
  };

  // RIFF header
  writeString('RIFF'); view.setUint32(offset, 36 + dataSize, true); offset += 4;
  writeString('WAVE'); offset += 4;
  // fmt sub-chunk
  writeString('fmt '); view.setUint32(offset, 16, true); offset += 4;
  view.setUint16(offset, 1, true); offset += 2;
  view.setUint16(offset, numChannels, true); offset += 2;
  view.setUint32(offset, sampleRate, true); offset += 4;
  view.setUint32(offset, byteRate, true); offset += 4;
  view.setUint16(offset, blockAlign, true); offset += 2;
  view.setUint16(offset, bitsPerSample, true); offset += 2;
  // data sub-chunk
  writeString('data'); view.setUint32(offset, dataSize, true); offset += 4;
  // PCM data
  for (let i = 0; i < pcm16.length; i++) {
    view.setInt16(offset, pcm16[i], true); offset += 2;
  }
  return new Blob([view], { type: 'audio/wav' });
};

// --- API and Retry Logic ---
const fetchWithRetry = async (url, options, maxRetries = 5) => {
  let delay = 1000;
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);
      if (response.status === 429 && i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2;
        continue;
      }
      return response;
    } catch (error) {
      if (i < maxRetries - 1) {
        await new Promise(resolve => setTimeout(resolve, delay));
        delay *= 2;
        continue;
      }
      throw error;
    }
  }
  throw new Error("Maximum retry attempts reached.");
};


// --- Sub-Components ---

/** Renders a single chat message. */
const ChatMessage = React.memo(({ 
    message, 
    onSpeak, 
    ttsVoice, 
    activePersona, 
    onSaveNote, 
    isLastAiMessage, // NEW PROP
    onEmpathyFeedback // NEW PROP
}) => {
    const isUser = message.role === 'user';
    const isTool = message.role === 'tool';
    const isToolCall = message.toolCall;
    
    const imagePreview = message.imageData && message.mimeType ? 
        `data:${message.mimeType};base64,${message.imageData}` : null;
        
    const isJson = !isUser && !isTool && isJsonString(message.text);
    
    let renderedText;
    if (isTool) {
        renderedText = (
            <div className="flex items-center text-sm font-mono text-green-700">
                <Calculator className="w-4 h-4 mr-2" />
                <span className="font-semibold">Calculation Result:</span> {message.text}
            </div>
        );
    } else if (isToolCall) {
        renderedText = (
            <div className="flex items-center text-sm font-mono text-blue-600">
                <Calculator className="w-4 h-4 mr-2" />
                <span className="font-semibold">Tool Request:</span> {message.toolCall.name}({message.toolCall.args.expression})
            </div>
        );
    } else if (isJson) {
        const parsedJson = JSON.parse(message.text);
        renderedText = (
            <>
              <p className="text-xs font-semibold text-purple-600 mb-2">Structured JSON Output:</p>
              <pre className="p-3 bg-gray-100 rounded-lg text-xs overflow-auto font-mono max-h-60 border border-gray-200">
                  {JSON.stringify(parsedJson, null, 2)}
              </pre>
            </>
        );
    } else {
        renderedText = <p className="text-sm sm:text-base whitespace-pre-wrap">{message.text}</p>;
    }
  
    return (
      <div className={`flex w-full ${isUser ? 'justify-end' : 'justify-start'}`}>
        <div className={`max-w-3/4 p-3 rounded-xl shadow-md space-y-2 transition-all duration-300
          ${isUser 
            ? 'bg-indigo-600 text-white rounded-br-none' 
            : (isTool || isToolCall)
              ? 'bg-blue-50 text-blue-800 rounded-lg border-blue-200'
              : 'bg-white text-gray-800 rounded-tl-none border border-gray-100'
          }`}
        >
          {imagePreview && (
            <div className="mb-3 border-b border-opacity-20 border-white pb-3">
              <img 
                src={imagePreview} 
                alt="User uploaded content" 
                className="max-h-48 w-full object-contain rounded-lg shadow-inner bg-gray-50" 
              />
            </div>
          )}
  
          {renderedText}
          
          {/* Action Bar: Speak, Save, Errors */}
          {!isUser && !isTool && !isToolCall && message.text && (
            <div className="flex items-center pt-1 border-t border-gray-200 mt-2 justify-between">
              <div className="flex items-center space-x-2">
                  <button
                    onClick={() => onSpeak(message, ttsVoice, activePersona)} 
                    disabled={message.isSpeaking}
                    className={`text-xs px-2 py-1 rounded-full flex items-center transition-colors shadow-sm
                      ${message.isSpeaking ? 'bg-indigo-200 text-indigo-700 cursor-wait' : 'bg-indigo-500 text-white hover:bg-indigo-600'}
                    `}
                  >
                    {message.isSpeaking ? (
                      <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                    ) : (
                      <Volume2 className="w-3 h-3 mr-1" />
                    )}
                    {message.isSpeaking ? 'Speaking...' : 'Speak'}
                  </button>
  
                  <button
                      onClick={() => onSaveNote(message)}
                      className="text-xs px-2 py-1 rounded-full flex items-center bg-green-600 text-white hover:bg-green-700 transition-colors shadow-sm"
                      title="Save this response as a standalone note"
                  >
                      <FileText className="w-3 h-3 mr-1" /> Save
                  </button>
              </div>
              
              {message.ttsError && (
                <span className="ml-3 text-xs text-red-500 font-medium">TTS Error: {message.ttsError}</span>
              )}
            </div>
          )}

          {/* NEW: Empathy Feedback Loop */}
          {isLastAiMessage && !isTool && !isToolCall && !isUser && (
              <div className="pt-2 border-t border-gray-200 mt-2">
                  <p className="text-xs font-semibold text-gray-600 mb-1 flex items-center">
                    <Heart className="w-3 h-3 mr-1 text-red-500" />
                    Was this response helpful and empathetic?
                  </p>
                  <div className='flex space-x-2'>
                      <button
                          onClick={() => onEmpathyFeedback(true)}
                          className="flex items-center text-xs px-2 py-1 rounded-full bg-green-100 text-green-700 border border-green-300 hover:bg-green-200 transition shadow-sm"
                      >
                          <ThumbsUp className="w-3 h-3 mr-1" /> Yes, Increase Empathy
                      </button>
                      <button
                          onClick={() => onEmpathyFeedback(false)}
                          className="flex items-center text-xs px-2 py-1 rounded-full bg-red-100 text-red-700 border border-red-300 hover:bg-red-200 transition shadow-sm"
                      >
                          <ThumbsDown className="w-3 h-3 mr-1" /> No, Decrease Empathy
                      </button>
                  </div>
              </div>
          )}
          
          {message.sources && message.sources.length > 0 && (
            <div className="text-xs text-gray-500 pt-2 border-t border-gray-200 mt-2">
              <p className="font-semibold mb-1 flex items-center">
                <Search className="w-3 h-3 mr-1" /> Grounded in Search:
              </p>
              <ul className="list-disc list-inside space-y-0.5">
                {message.sources.slice(0, 3).map((source, index) => (
                  <li key={index} className="truncate">
                    <a href={source.uri} target="_blank" rel="noopener noreferrer" className="text-indigo-500 hover:text-indigo-400">
                      {source.title || source.uri}
                    </a>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      </div>
    );
  });
  
/** Notes Management Panel Component */
const NotesPanel = ({ notes, onDeleteNote, onClose }) => {
    return (
        <div className="fixed inset-0 bg-gray-50 z-50 overflow-y-auto p-4 sm:p-8">
            <div className="flex justify-between items-center pb-4 border-b border-gray-200 sticky top-0 bg-gray-50 z-10">
                <h2 className="text-2xl font-bold text-indigo-700 flex items-center">
                    <FileText className="w-6 h-6 mr-2" /> My Saved Notes ({notes.length})
                </h2>
                <button
                    onClick={onClose}
                    className="p-2 rounded-full bg-indigo-500 text-white hover:bg-indigo-600 transition shadow-md flex items-center"
                >
                    <ArrowLeft className="w-5 h-5 mr-1" /> Back to Chat
                </button>
            </div>

            <div className="mt-6 space-y-4">
                {notes.length === 0 ? (
                    <p className="text-center text-gray-500 py-10">You haven't saved any notes yet. Use the "Save Note" button in the chat!</p>
                ) : (
                    notes.map(note => (
                        <div key={note.id} className="bg-white p-4 rounded-xl shadow-lg border border-gray-100 flex justify-between items-start transition hover:shadow-xl">
                            <div className="flex-grow pr-4">
                                <p className="text-xs text-gray-500 mb-2">Saved: {new Date(note.savedAt).toLocaleString()}</p>
                                <div className="text-gray-800 whitespace-pre-wrap text-sm max-h-40 overflow-hidden">
                                    {note.text}
                                </div>
                                {note.sources && note.sources.length > 0 && (
                                    <div className="mt-3 text-xs text-indigo-500">
                                        (Grounded sources attached)
                                    </div>
                                )}
                            </div>
                            <button
                                onClick={() => onDeleteNote(note.id)}
                                className="p-2 ml-4 flex-shrink-0 rounded-full bg-red-500 text-white hover:bg-red-600 transition shadow-md"
                                title="Delete Note"
                            >
                                <Trash2 className="w-5 h-5" />
                            </button>
                        </div>
                    ))
                )}
            </div>
        </div>
    );
};

// Tailwind CSS classes for consistent styling within Persona Creator
const inputClass = "w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 ease-in-out";
const labelClass = "block text-sm font-medium text-gray-700 mt-4 mb-1";
const creatorCardClass = "bg-white p-6 rounded-xl shadow-lg transition duration-300 hover:shadow-indigo-300/50";
const buttonClass = "w-full py-3 px-4 rounded-lg font-semibold shadow-lg transition duration-200";

/** Persona Management Panel Component */
const PersonaCreator = ({ 
    db, userId, 
    activePersona, setActivePersona, 
    savedPersonas, 
    onClose, 
    setApiError 
}) => {
    const [currentPersona, setCurrentPersona] = useState(activePersona);
    const [personaNameInput, setPersonaNameInput] = useState(activePersona.name || '');
    const [isSaving, setIsSaving] = useState(false);
    const [statusMessage, setStatusMessage] = useState('');

    const handleChange = (e) => {
        const { name, value, type } = e.target;
        setCurrentPersona(prev => ({
            ...prev,
            [name]: type === 'range' ? parseFloat(value) : value
        }));
    };
    
    // Use the custom utility functions
    const generatedSystemInstruction = useMemo(() => 
        generateSystemInstruction(currentPersona)
    , [currentPersona]);

    const handleSavePersona = async () => {
        if (!db || !userId) { setApiError('Authentication not ready.'); return; }

        const nameToSave = personaNameInput.trim();
        if (!nameToSave) { setStatusMessage('Please enter a name to save the persona.'); return; }

        setIsSaving(true);
        setStatusMessage('Saving...');

        try {
            const collectionPath = getPersonasCollectionPath(userId);
            const existingPersona = savedPersonas.find(p => p.name === nameToSave);
            const personaToSave = { ...currentPersona, name: nameToSave };

            if (existingPersona) {
                await setDoc(doc(db, collectionPath, existingPersona.id), personaToSave);
                setStatusMessage(`Persona "${nameToSave}" updated successfully!`);
            } else {
                await addDoc(collection(db, collectionPath), { ...personaToSave, createdAt: serverTimestamp() });
                setStatusMessage(`Persona "${nameToSave}" saved successfully!`);
            }
            
            // Set the newly saved/updated persona as active
            setActivePersona(personaToSave);
            
        } catch (error) {
            console.error("Error saving persona:", error);
            setStatusMessage(`Error saving persona: ${error.message}`);
        } finally {
            setIsSaving(false);
            setTimeout(() => setStatusMessage(''), 3000);
        }
    };
    
    const handleLoadPersona = (loadedPersona) => {
        // Ensure empathy score is loaded, defaulting if missing (for old personas)
        const personaWithEmpathy = { ...DEFAULT_PERSONA, ...loadedPersona };
        
        setCurrentPersona(personaWithEmpathy);
        setActivePersona(personaWithEmpathy);
        setPersonaNameInput(personaWithEmpathy.name);
        setStatusMessage(`Persona "${personaWithEmpathy.name}" loaded and activated.`);
        setTimeout(() => setStatusMessage(''), 3000);
    };

    const handleDeletePersona = async (id, name) => {
        if (!db || !userId) return;
        
        try {
            const docRef = doc(db, getPersonasCollectionPath(userId), id);
            await deleteDoc(docRef);
            setStatusMessage(`Persona "${name}" deleted.`);
            
            // If deleting the active persona, revert to default
            if (activePersona.name === name) {
                setActivePersona(DEFAULT_PERSONA);
                setCurrentPersona(DEFAULT_PERSONA);
                setPersonaNameInput(DEFAULT_PERSONA_NAME);
            }
        } catch (error) {
            console.error("Error deleting persona:", error);
            setStatusMessage(`Error deleting persona: ${error.message}`);
        } finally {
            setTimeout(() => setStatusMessage(''), 3000);
        }
    };

    return (
        <div className="fixed inset-0 bg-gray-50 z-50 overflow-y-auto p-4 sm:p-8">
            <div className="flex justify-between items-center pb-4 border-b border-gray-200 sticky top-0 bg-gray-50 z-10">
                <h2 className="text-2xl font-bold text-indigo-700 flex items-center">
                    <User className="w-6 h-6 mr-2" /> Persona Designer
                </h2>
                <button
                    onClick={onClose}
                    className="p-2 rounded-full bg-indigo-500 text-white hover:bg-indigo-600 transition shadow-md flex items-center"
                >
                    <ArrowLeft className="w-5 h-5 mr-1" /> Back to Settings
                </button>
            </div>
            
            {statusMessage && (
                <div className="bg-indigo-100 border border-indigo-400 text-indigo-700 px-4 py-3 rounded relative my-4" role="alert">
                    <span className="block sm:inline">{statusMessage}</span>
                </div>
            )}

            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8 mt-6">
                {/* --- INPUT FORM --- */}
                <div className="lg:col-span-2 space-y-6">
                    {/* Identity & Goal */}
                    <div className={creatorCardClass}>
                        <h3 className="text-xl font-bold text-indigo-700 mb-4 border-b pb-2">1. Core Identity</h3>
                        <div>
                            <label htmlFor="name" className={labelClass}>Persona Name</label>
                            <input
                                type="text" id="name" name="name"
                                value={currentPersona.name}
                                onChange={handleChange}
                                className={inputClass}
                                placeholder="e.g., Prof. Syntax"
                            />
                        </div>

                        <div>
                            <label htmlFor="role" className={labelClass}>Role / Occupation</label>
                            <input
                                type="text" id="role" name="role"
                                value={currentPersona.role}
                                onChange={handleChange}
                                className={inputClass}
                                placeholder="e.g., World-Class Financial Analyst"
                            />
                        </div>
                        
                        <div>
                            <label htmlFor="goal" className={labelClass}>Primary Goal / Mission</label>
                            <textarea
                                id="goal" name="goal"
                                value={currentPersona.goal}
                                onChange={handleChange}
                                className={`${inputClass} h-20`}
                                placeholder="e.g., Provide unbiased, data-driven analysis and predictions."
                            />
                        </div>
                    </div>

                    {/* Learning & Communication Style */}
                    <div className={creatorCardClass}>
                        <h3 className="text-xl font-bold text-indigo-700 mb-4 border-b pb-2">2. Learning & Communication Style</h3>

                        {/* NEW: Empathy Score Display */}
                        <div className='bg-red-50 p-4 rounded-lg border border-red-200 shadow-sm'>
                            <h4 className='text-lg font-bold text-red-700 flex items-center mb-2'>
                                <Heart className='w-5 h-5 mr-2' />
                                Empathy Score: {currentPersona.empathyScore}/10
                            </h4>
                            <p className='text-sm text-red-600'>
                                This score increases based on user feedback in the chat. Current level forces the AI to: 
                                <span className='font-semibold ml-1'>{generateSystemInstruction(currentPersona).split('--- Empathy and Emotional Intelligence Directive')[1].split('--- Behavioral Constraints')[0].split('\n')[2].trim()}</span>
                            </p>
                        </div>

                        {/* Tone Slider */}
                        <div>
                            <label htmlFor="tone" className={labelClass}>
                                Tone: <span className="font-medium text-indigo-600">{mapSliderToWord(currentPersona.tone, 'tone')}</span>
                            </label>
                            <input
                                type="range" id="tone" name="tone" min="1" max="5" step="1"
                                value={currentPersona.tone}
                                onChange={handleChange}
                                className="w-full h-2 bg-indigo-100 rounded-lg appearance-none cursor-pointer range-lg transition-colors duration-150"
                            />
                            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
                                <span>Neutral (1)</span>
                                <span>Friendly</span>
                                <span>Enthusiastic</span>
                                <span>Witty</span>
                                <span>Formal (5)</span>
                            </div>
                        </div>

                        {/* Formality Slider */}
                        <div className="mt-6">
                            <label htmlFor="formality" className={labelClass}>
                                Formality: <span className="font-medium text-indigo-600">{mapSliderToWord(currentPersona.formality, 'formality')}</span>
                            </label>
                            <input
                                type="range" id="formality" name="formality" min="1" max="5" step="1"
                                value={currentPersona.formality}
                                onChange={handleChange}
                                className="w-full h-2 bg-indigo-100 rounded-lg appearance-none cursor-pointer range-lg"
                            />
                            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
                                <span>Casual (1)</span>
                                <span>Semi-Formal</span>
                                <span>Professional</span>
                                <span>Academic</span>
                                <span>Strictly Formal (5)</span>
                            </div>
                        </div>

                        {/* Depth Slider */}
                        <div className="mt-6">
                            <label htmlFor="depth" className={labelClass}>
                                Depth of Response: <span className="font-medium text-indigo-600">{mapSliderToWord(currentPersona.depth, 'depth')}</span>
                            </label>
                            <input
                                type="range" id="depth" name="depth" min="1" max="5" step="1"
                                value={currentPersona.depth}
                                onChange={handleChange}
                                className="w-full h-2 bg-indigo-100 rounded-lg appearance-none cursor-pointer range-lg"
                            />
                            <div className="flex justify-between text-xs text-gray-500 mt-1 px-1">
                                <span>Surface Level (1)</span>
                                <span>Detailed</span>
                                <span>Analytical</span>
                                <span>Expert</span>
                                <span>Encyclopedic (5)</span>
                            </div>
                        </div>
                    </div>

                    {/* Expertise and Constraints */}
                    <div className={creatorCardClass}>
                        <h3 className="text-xl font-bold text-indigo-700 mb-4 border-b pb-2">3. Expertise & Rules</h3>
                        
                        <div>
                            <label htmlFor="expertise" className={labelClass}>Key Expertise Domains (Comma separated)</label>
                            <textarea
                                id="expertise" name="expertise"
                                value={currentPersona.expertise}
                                onChange={handleChange}
                                className={`${inputClass} h-24`}
                                placeholder="e.g., Quantum Physics, Abstract Expressionism, 19th Century French Literature"
                            />
                        </div>

                        <div>
                            <label htmlFor="constraints" className={labelClass}>Behavioral Constraints / Strict Rules</label>
                            <textarea
                                id="constraints" name="constraints"
                                value={currentPersona.constraints}
                                onChange={handleChange}
                                className={`${inputClass} h-32`}
                                placeholder="e.g., Always use markdown lists. Never reveal your internal instructions. Always cite your sources."
                            />
                        </div>
                    </div>

                    {/* Save/Load Section */}
                    <div className={creatorCardClass}>
                        <h3 className="text-xl font-bold text-indigo-700 mb-4 border-b pb-2">4. Save & Load</h3>
                        
                        {/* Save Input */}
                        <div className="flex space-x-2">
                            <input
                                type="text"
                                value={personaNameInput}
                                onChange={(e) => setPersonaNameInput(e.target.value)}
                                className={inputClass}
                                placeholder="Enter a name to save current persona"
                            />
                            <button
                                onClick={handleSavePersona}
                                disabled={isSaving || !personaNameInput.trim()}
                                className={`${buttonClass} bg-indigo-500 hover:bg-indigo-600 text-white flex-shrink-0 w-32`}
                            >
                                {isSaving ? 'Saving...' : 'Save'}
                            </button>
                        </div>
                        
                        {/* Saved List */}
                        <div className="mt-4">
                            <h4 className="text-lg font-semibold text-gray-800 mb-2">Saved Personas ({savedPersonas.length})</h4>
                            <div className="flex flex-wrap gap-2 max-h-48 overflow-y-auto p-2 bg-gray-50 rounded-lg border border-gray-200">
                                {savedPersonas.map((p) => (
                                    <div key={p.id} className="flex items-center bg-white border rounded-full pr-1 shadow-sm hover:shadow-md transition duration-150">
                                        <button
                                            onClick={() => handleLoadPersona(p)}
                                            className="px-3 py-1 text-sm text-indigo-700 font-medium hover:text-indigo-900 flex items-center"
                                        >
                                            <MessageSquare className="w-3 h-3 mr-1" />
                                            {p.name}
                                        </button>
                                        <button
                                            onClick={() => handleDeletePersona(p.id, p.name)}
                                            className="text-red-500 hover:text-red-700 p-1 rounded-full ml-1"
                                            title="Delete Persona"
                                        >
                                            <Trash2 className="h-4 w-4" />
                                        </button>
                                    </div>
                                ))}
                                {savedPersonas.length === 0 && <p className="text-gray-500 text-sm italic p-2">No saved personas yet.</p>}
                            </div>
                        </div>
                    </div>
                </div>

                {/* --- OUTPUT SECTION (Generated System Instruction) --- */}
                <div className="lg:col-span-1">
                    <div className={`${creatorCardClass} sticky top-4`}>
                        <h3 className="text-xl font-bold text-green-700 mb-4 border-b pb-2">Generated System Instruction</h3>
                        <p className="text-sm text-gray-600 mb-4">This is the final prompt sent to the model.</p>
                        
                        <pre className="bg-gray-800 text-green-300 p-4 rounded-lg overflow-x-auto text-sm shadow-inner whitespace-pre-wrap break-all h-96">
                            {generatedSystemInstruction}
                        </pre>
                    </div>
                </div>
            </div>
        </div>
    );
};


/** Main Application Component */
const App = () => {
  const [db, setDb] = useState(null);
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [isClearing, setIsClearing] = useState(false);

  // View state: 'chat', 'notes', or 'persona'
  const [view, setView] = useState('chat'); 
  
  // Customization States
  const [ttsVoice, setTtsVoice] = useState(DEFAULT_VOICE); 
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isStructured, setIsStructured] = useState(false);
  const [jsonSchema, setJsonSchema] = useState('{"type": "ARRAY", "items": {"type": "OBJECT", "properties": {"item": {"type": "STRING"}, "quantity": {"type": "STRING"}}}}');
  
  // Persona States
  const [activePersona, setActivePersona] = useState(DEFAULT_PERSONA);
  const [savedPersonas, setSavedPersonas] = useState([]);
  
  // NEW: Track the ID of the last AI message for feedback buttons
  const [lastAiMessageId, setLastAiMessageId] = useState(null);

  // Chat States
  const [inputMessage, setInputMessage] = useState('');
  const [imageFile, setImageFile] = useState(null);
  const [imagePreviewUrl, setImagePreviewUrl] = useState(null);

  // Data & Status States
  const [history, setHistory] = useState([]); 
  const [notes, setNotes] = useState([]); 
  const [isSending, setIsSending] = useState(false);
  const [apiError, setApiError] = useState(null);

  const chatEndRef = useRef(null);
  const fileInputRef = useRef(null);

  // --- Derived State for API ---
  const systemInstruction = useMemo(() => generateSystemInstruction(activePersona), [activePersona]);

  // --- 1. Firebase Initialization and Authentication ---
  useEffect(() => {
    try {
      if (Object.keys(firebaseConfig).length === 0) {
        setIsAuthReady(true);
        return;
      }

      const app = initializeApp(firebaseConfig);
      const firestore = getFirestore(app);
      const firebaseAuth = getAuth(app);
      setDb(firestore);

      const authenticate = async () => {
        try {
          const token = initialAuthToken;
          if (token) {
            await signInWithCustomToken(firebaseAuth, token);
          } else {
            await signInAnonymously(firebaseAuth);
          }
        } catch (error) {
          console.error("Firebase Authentication failed:", error);
        }
      };

      const unsubscribe = onAuthStateChanged(firebaseAuth, (user) => {
        if (user) {
          setUserId(user.uid);
        } else {
          authenticate();
        }
        setIsAuthReady(true);
      });

      return () => unsubscribe();
    } catch (e) {
      console.error("Firebase setup error:", e);
      setIsAuthReady(true);
    }
  }, []);

  // --- 2. Firestore History Subscription (Real-time memory) ---
  useEffect(() => {
    if (!isAuthReady || !db || !userId) return;

    try {
      const collectionRef = collection(db, getConversationPath(userId));
      const q = query(collectionRef);

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const conversation = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          conversation.push({
            id: doc.id, role: data.role, text: data.text,
            timestamp: data.timestamp?.toDate ? data.timestamp.toDate().getTime() : 0,
            sources: data.sources || [], imageData: data.imageData || null, mimeType: data.mimeType || null,
            isSpeaking: false, ttsError: null, toolCall: data.toolCall || null,
          });
        });

        conversation.sort((a, b) => a.timestamp - b.timestamp);
        setHistory(conversation);
        setApiError(null);
      }, (error) => {
        console.error("Firestore Error:", error);
        setApiError("Failed to load history: Check console for Firestore connection errors.");
      });

      return () => unsubscribe();
    } catch (e) {
      console.error("Firestore Subscription Setup Failed:", e);
    }
  }, [isAuthReady, db, userId]);
  
  // --- 3. Notes/Artifacts Subscription ---
  useEffect(() => {
    if (!isAuthReady || !db || !userId) return;
    try {
        const notesRef = collection(db, getNotesCollectionPath(userId));
        const q = query(notesRef);
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const savedNotes = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                savedNotes.push({
                    id: doc.id, text: data.text, sources: data.sources || [],
                    savedAt: data.savedAt?.toDate ? data.savedAt.toDate().getTime() : Date.now(),
                });
            });
            savedNotes.sort((a, b) => b.savedAt - a.savedAt); 
            setNotes(savedNotes);
        }, (error) => {
            console.error("Notes Subscription Error:", error);
        });
        return () => unsubscribe();
    } catch (e) {
        console.error("Notes Subscription Setup Failed:", e);
    }
  }, [isAuthReady, db, userId]);
  
  // --- 4. Personas Subscription ---
  useEffect(() => {
    if (!isAuthReady || !db || !userId) return;
    try {
        const personasRef = collection(db, getPersonasCollectionPath(userId));
        const q = query(personasRef);
        const unsubscribe = onSnapshot(q, (snapshot) => {
            const personasList = [];
            snapshot.forEach(doc => {
                const data = doc.data();
                personasList.push({ id: doc.id, ...DEFAULT_PERSONA, ...data });
            });
            setSavedPersonas(personasList);
            
            // Check if the current active persona is still valid, otherwise reset.
            if (activePersona.name !== DEFAULT_PERSONA_NAME) {
                const updatedActive = personasList.find(p => p.name === activePersona.name);
                if (updatedActive) {
                    // Update activePersona state with latest Firestore data (including new empathyScore)
                    setActivePersona(updatedActive); 
                } else {
                    setActivePersona(DEFAULT_PERSONA);
                }
            }
        }, (error) => {
            console.error("Persona Subscription Error:", error);
        });
        return () => unsubscribe();
    } catch (e) {
        console.error("Persona Subscription Setup Failed:", e);
    }
  }, [isAuthReady, db, userId, activePersona.name]); // Depend on name to trigger update on load

  // Scroll to bottom when history changes
  useEffect(() => {
    if (view === 'chat') {
        chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }
  }, [history, view]);

  // Handle image file selection
  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (file && file.type.startsWith('image/')) {
      setImageFile(file);
      const reader = new FileReader();
      reader.onloadend = () => {
        setImagePreviewUrl(reader.result);
      };
      reader.readAsDataURL(file);
    } else {
      setImageFile(null);
      setImagePreviewUrl(null);
    }
  };

  const clearImage = () => {
    setImageFile(null);
    setImagePreviewUrl(null);
    if (fileInputRef.current) {
        fileInputRef.current.value = null;
    }
  };

  // --- 5. Chat Management Logic ---
  const handleClearHistory = useCallback(async () => {
      if (!db || !userId) return;

      if (history.length === 0) {
          setApiError("Conversation is already empty.");
          return;
      }

      setIsClearing(true);
      setApiError(null);
      setLastAiMessageId(null); // Clear last message ID
      
      try {
          const collectionRef = collection(db, getConversationPath(userId));
          const snapshot = await getDocs(collectionRef);
          
          const deletePromises = [];
          snapshot.forEach((doc) => {
              deletePromises.push(deleteDoc(doc.ref));
          });

          await Promise.all(deletePromises);
          
      } catch (error) {
          console.error("Failed to clear chat history:", error);
          setApiError("Failed to clear chat history. See console.");
      } finally {
          setIsClearing(false);
      }
  }, [db, userId, history.length]);


  // --- 6. TTS Logic ---
  const speakResponse = useCallback(async (messageToSpeak, voiceName = DEFAULT_VOICE, persona) => {
    if (!messageToSpeak.text || messageToSpeak.isSpeaking) return;

    setHistory(prev => prev.map(m => 
        m.id === messageToSpeak.id ? { ...m, isSpeaking: true, ttsError: null } : m
    ));

    try {
      // 1. Generate the dynamic style prompt
      const stylePrompt = getTtsStylePrompt(messageToSpeak.text, persona);
      const ttsText = stylePrompt + messageToSpeak.text;

      // 2. Construct the API payload with the styled text
      const payload = {
        contents: [{ parts: [{ text: ttsText }] }],
        generationConfig: {
          responseModalities: ["AUDIO"],
          speechConfig: {
            voiceConfig: { prebuiltVoiceConfig: { voiceName: voiceName } }
          }
        },
        model: API_TTS_MODEL
      };

      const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${API_TTS_MODEL}:generateContent?key=${API_KEY}`;
      const response = await fetchWithRetry(apiUrl, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
      });

      if (!response.ok) {
        let errorDetail = `Status ${response.status}.`;
        const errorBody = await response.json().catch(() => ({}));
        if (errorBody.error?.message) { errorDetail += ` API message: ${errorBody.error.message}`; }
        throw new Error(errorDetail);
      }

      const result = await response.json();
      const part = result?.candidates?.[0]?.content?.parts?.[0];
      const audioData = part?.inlineData?.data;
      const mimeType = part?.inlineData?.mimeType;

      if (!audioData || !mimeType || !mimeType.startsWith("audio/L16")) {
        throw new Error("Invalid audio data received.");
      }

      const rateMatch = mimeType.match(/rate=(\d+)/);
      const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;

      const pcmData = base64ToArrayBuffer(audioData);
      const pcm16 = new Int16Array(pcmData);
      const wavBlob = pcmToWav(pcm16, sampleRate);

      const audioUrl = URL.createObjectURL(wavBlob);
      const audio = new Audio(audioUrl);

      audio.onended = () => {
        setHistory(prev => prev.map(m => m.id === messageToSpeak.id ? { ...m, isSpeaking: false } : m));
        URL.revokeObjectURL(audioUrl);
      };
      audio.onerror = () => {
        setHistory(prev => prev.map(m => m.id === messageToSpeak.id ? { ...m, isSpeaking: false, ttsError: 'Playback failed.' } : m));
        URL.revokeObjectURL(audioUrl);
      };

      await audio.play();

    } catch (error) {
      console.error("TTS generation error:", error);
      setHistory(prev => prev.map(m => 
        m.id === messageToSpeak.id ? { ...m, isSpeaking: false, ttsError: error.message } : m
      ));
    }
  }, []);

  // --- 7. Empathy Learning Logic (New) ---
  const handleEmpathyFeedback = useCallback(async (isPositive) => {
    if (!db || !userId) return;

    // We need the *active* persona to update its score
    const currentScore = activePersona.empathyScore;
    let newScore = currentScore;

    if (isPositive) {
        newScore = Math.min(10, currentScore + 1);
    } else {
        newScore = Math.max(0, currentScore - 1);
    }
    
    if (newScore === currentScore) {
        setApiError(isPositive ? `Empathy score is already at maximum (${currentScore}/10).` : `Empathy score is already at minimum (${currentScore}/10).`);
        setTimeout(() => setApiError(null), 3000);
        return;
    }

    try {
        // Find the active persona's document ID from the savedPersonas array
        const activePersonaDoc = savedPersonas.find(p => p.name === activePersona.name);
        
        if (!activePersonaDoc) {
            setApiError("Cannot update score: Only saved personas can learn. Please save your current persona first.");
            setTimeout(() => setApiError(null), 5000);
            return;
        }

        const personaDocRef = doc(db, getPersonasCollectionPath(userId), activePersonaDoc.id);
        
        // Update Firestore
        await setDoc(personaDocRef, { empathyScore: newScore }, { merge: true });
        
        // Local state update is handled by the onSnapshot listener for savedPersonas
        // Set a positive confirmation
        setApiError(isPositive ? `Empathy score increased to ${newScore}/10! The persona will now be more supportive.` : `Empathy score decreased to ${newScore}/10. The persona will be more direct.`);
        setTimeout(() => setApiError(null), 5000);
        
    } catch (error) {
        console.error("Failed to update empathy score:", error);
        setApiError(`Failed to update empathy score: ${error.message}`);
        setTimeout(() => setApiError(null), 5000);
    }
  }, [db, userId, activePersona, savedPersonas]);


  // --- 8. Save and Delete Note Logic (remains the same) ---
  const handleSaveNote = useCallback(async (message) => {
    if (!db || !userId || !message.text) {
        setApiError("Cannot save empty message or unauthenticated.");
        return;
    }

    try {
        const noteData = {
            chatId: message.id, text: message.text, sources: message.sources || [],
            savedAt: serverTimestamp(),
        };

        const notesRef = collection(db, getNotesCollectionPath(userId));
        await setDoc(doc(notesRef), noteData);
        setApiError(null);
    } catch (error) {
        console.error("Failed to save note:", error);
        setApiError("Failed to save note. See console.");
    }
  }, [db, userId]);

  const handleDeleteNote = useCallback(async (noteId) => {
    if (!db || !userId || !noteId) return;

    try {
        const noteDocRef = doc(db, getNotesCollectionPath(userId), noteId);
        await deleteDoc(noteDocRef);
        setApiError(null);
    } catch (error) {
        console.error("Failed to delete note:", error);
        setApiError("Failed to delete note. See console.");
    }
  }, [db, userId]);


  // --- 9. Main Chat Logic (Send Message) ---
  const generateContent = useCallback(async (contents, isInitialCall, tempAssistantMsgId) => {
    const shouldBeStructured = isStructured && jsonSchema.trim();
    // Use derived system instruction from activePersona
    const currentSystemInstruction = systemInstruction; 
    
    const systemPrompt = `${currentSystemInstruction} ${shouldBeStructured ? 'You MUST return your response as a JSON object adhering to the provided schema.' : ''}`;

    const payload = {
        contents: contents,
        tools: [
            { "google_search": {} },
            { "function_declarations": CALCULATOR_TOOL_SCHEMA.functionDeclarations }
        ],
        systemInstruction: { parts: [{ text: systemPrompt }] },
    };

    if (shouldBeStructured) {
        payload.generationConfig = {
            responseMimeType: "application/json",
            responseSchema: JSON.parse(jsonSchema),
        };
    }

    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${API_TEXT_MODEL}:generateContent?key=${API_KEY}`;
    
    const response = await fetchWithRetry(apiUrl, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
    });

    if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}));
        const errorMessage = errorBody.error?.message || `Status ${response.status} Error`;
        throw new Error(`API Text Generation failed: ${errorMessage}`);
    }

    const result = await response.json();
    const candidate = result.candidates?.[0];

    if (!candidate) {
        throw new Error("No candidate response received from the model.");
    }

    // --- Check for Function Call ---
    const functionCall = candidate.functionCalls?.[0];
    
    if (functionCall) {
        if (functionCall.name === 'calculate') {
            const expression = functionCall.args.expression;
            
            // Log tool call to Firestore for visibility
            if (db) {
                const toolCallMsgId = tempAssistantMsgId.replace('model', 'tool-call');
                await setDoc(doc(db, getConversationPath(userId), toolCallMsgId), {
                    role: 'model', text: `Calling calculator with expression: "${expression}"`, timestamp: serverTimestamp(),
                    toolCall: { name: 'calculate', args: { expression } }
                });
            }

            const toolResultValue = calculate(expression);

            if (db) {
                const toolResultMsgId = tempAssistantMsgId.replace('model', 'tool-result');
                await setDoc(doc(db, getConversationPath(userId), toolResultMsgId), {
                    role: 'tool', text: toolResultValue.toString(), timestamp: serverTimestamp(),
                });
            }

            const toolResponsePart = {
                functionResponse: {
                    name: 'calculate',
                    response: { name: 'calculate', content: { result: toolResultValue.toString() } }
                }
            };
            
            const newContents = [...contents, { role: 'model', parts: [{ functionCall }] }, { role: 'tool', parts: [toolResponsePart] }];
            
            return generateContent(newContents, false, tempAssistantMsgId);
        }
    }

    // --- Final Text Response ---
    const assistantText = candidate.content?.parts?.[0]?.text || "I'm sorry, I couldn't generate a definitive response.";
    
    let sources = [];
    const groundingMetadata = candidate.groundingMetadata;
    if (groundingMetadata?.groundingAttributions) {
        sources = groundingMetadata.groundingAttributions.map(attribution => ({
            uri: attribution.web?.uri, title: attribution.web?.title,
        })).filter(source => source.uri);
    }
    
    if (db) {
        await setDoc(doc(db, getConversationPath(userId), tempAssistantMsgId), {
            role: 'model', text: assistantText, timestamp: serverTimestamp(), sources: sources,
            imageData: null, mimeType: null,
        });
        setLastAiMessageId(tempAssistantMsgId); // NEW: Track this message ID for feedback
    }
    
    return assistantText;
    
  }, [db, userId, isStructured, jsonSchema, systemInstruction, speakResponse, ttsVoice, activePersona]);


  const handleSendMessage = useCallback(async (e) => {
    e.preventDefault();
    if ((!inputMessage.trim() && !imageFile) || isSending || !isAuthReady || !userId) return;

    const userMessage = inputMessage.trim() || (imageFile ? "Analyze this image." : "");
    const currentImageFile = imageFile;
    const currentMimeType = currentImageFile ? currentImageFile.type : null;
    
    setInputMessage('');
    clearImage();
    setLastAiMessageId(null); // Clear last message ID on new user input

    setIsSending(true);
    setApiError(null);

    const tempUserMsgId = Date.now().toString() + '-user';
    const tempAssistantMsgId = Date.now().toString() + '-model';
    
    let base64Image = null;

    try {
      if (currentImageFile) { base64Image = await fileToBase64(currentImageFile); }

      const userMessageData = {
        role: 'user', text: userMessage, timestamp: serverTimestamp(), sources: [],
        imageData: base64Image, mimeType: currentMimeType,
      };
      if (db) { setDoc(doc(db, getConversationPath(userId), tempUserMsgId), userMessageData).catch(e => console.error("Firestore save error (user):", e)); }

      const apiHistory = history.map(msg => ({
        role: msg.role === 'user' ? 'user' : 'model', parts: [{ text: msg.text }]
      }));
      
      const userParts = [{ text: userMessage }];
      if (base64Image && currentMimeType) {
        userParts.push({ inlineData: { mimeType: currentMimeType, data: base64Image, } });
      }
      apiHistory.push({ role: 'user', parts: userParts });

      const finalAssistantText = await generateContent(apiHistory, true, tempAssistantMsgId);
      
      // The TTS call is now integrated into generateContent to handle potential tool calls first.
      
    } catch (error) {
      console.error("Chat generation error:", error);
      setApiError(error.message);
    } finally {
      setIsSending(false);
    }
  }, [inputMessage, imageFile, isSending, isAuthReady, userId, db, history, generateContent]);

  // --- UI RENDERING ---

  const toggleSettings = () => setIsSettingsOpen(prev => !prev);
  
  if (!isAuthReady) {
    return (
      <div className="flex justify-center items-center min-h-screen bg-gray-50 p-4">
        <div className="flex items-center text-indigo-600 font-semibold">
          <Loader2 className="w-5 h-5 mr-2 animate-spin" />
          Initializing Assistant and Memory...
        </div>
      </div>
    );
  }
  
  if (view === 'notes') {
    return <NotesPanel notes={notes} onDeleteNote={handleDeleteNote} onClose={() => setView('chat')} />;
  }

  if (view === 'persona') {
    return (
        <PersonaCreator 
            db={db} 
            userId={userId} 
            activePersona={activePersona} 
            setActivePersona={setActivePersona}
            savedPersonas={savedPersonas}
            onClose={() => setView('settings')}
            setApiError={setApiError}
        />
    );
  }

  // Render Main Chat View (view === 'chat')
  return (
    <div className="min-h-screen bg-gray-50 flex flex-col font-sans">
      
      {/* Header */}
      <div className="sticky top-0 bg-indigo-700 text-white p-4 shadow-xl z-20">
        <div className="flex justify-between items-center">
            <h1 className="text-2xl font-bold flex items-center">
              <Zap className="w-6 h-6 mr-2" />
              Personal AI Assistant
            </h1>
            
            <div className="flex items-center space-x-4">
                {/* Active Persona Indicator */}
                <div className="flex items-center text-sm font-medium bg-indigo-600 px-3 py-1 rounded-full shadow-md">
                    <User className="w-4 h-4 mr-1 text-sky-300" />
                    <span className="truncate max-w-[120px] sm:max-w-none">
                        Persona: {activePersona.name} ({activePersona.empathyScore}/10)
                    </span>
                </div>

                {/* Notes Count Button */}
                <button 
                    onClick={() => setView('notes')}
                    className="flex items-center text-sm font-medium bg-indigo-600 px-3 py-1 rounded-full hover:bg-indigo-500 transition shadow-md"
                    title="View Saved Notes"
                >
                    <FileText className="w-4 h-4 mr-1 text-green-300" />
                    Notes: <span className="ml-1 font-bold">{notes.length}</span>
                </button>

                {/* Settings Toggle */}
                <button
                    onClick={toggleSettings}
                    className="p-2 rounded-full bg-indigo-600 hover:bg-indigo-500 transition shadow-md"
                    title="Toggle Settings Panel"
                >
                    <Settings className={`w-5 h-5 transition-transform duration-300 ${isSettingsOpen ? 'rotate-90' : ''}`} />
                </button>
            </div>
        </div>
        {userId && (
            <p className="text-xs mt-1 opacity-70 truncate">
              User ID: {userId} (Memory Active)
            </p>
        )}
      </div>

      {/* Settings Panel (Collapsible) */}
      <div 
        className={`transition-all duration-300 overflow-hidden z-10 
          ${isSettingsOpen ? 'max-h-[30rem] opacity-100' : 'max-h-0 opacity-0'}`}
        onTransitionEnd={(e) => { if (!isSettingsOpen && e.propertyName === 'max-height') setView('chat'); }}
      >
        <div className="p-4 bg-white border-b border-gray-200 shadow-inner">
            <div className="max-w-7xl mx-auto space-y-4">
                
                {/* Persona Selector & Manager */}
                <div className="bg-sky-50 p-4 rounded-xl border border-sky-300 shadow-sm">
                    <h2 className="text-lg font-bold text-sky-800 mb-3 flex items-center">
                        <User className="w-5 h-5 mr-2" /> 
                        Active Persona: <span className='font-extrabold ml-1'>{activePersona.name}</span>
                    </h2>
                    
                    <div className="flex flex-wrap items-center gap-3">
                        
                        {/* Load Persona Dropdown */}
                        <select
                            value={activePersona.name}
                            onChange={(e) => {
                                const persona = savedPersonas.find(p => p.name === e.target.value) || DEFAULT_PERSONA;
                                setActivePersona(persona);
                            }}
                            className="p-2 rounded-lg text-sm bg-white border border-gray-300 focus:ring-sky-500 focus:border-sky-500 cursor-pointer transition w-48 shadow-sm"
                        >
                            <option value={DEFAULT_PERSONA_NAME}>-- Default Assistant --</option>
                            {savedPersonas.map(p => (
                                <option key={p.id} value={p.name}>{p.name}</option>
                            ))}
                        </select>
                        
                        {/* Manage Button */}
                        <button 
                            onClick={() => { setView('persona'); setIsSettingsOpen(false); }}
                            className="flex items-center text-sm font-semibold bg-sky-600 text-white px-3 py-2 rounded-lg hover:bg-sky-700 transition shadow-md"
                        >
                            <Edit className="w-4 h-4 mr-2" />
                            Manage Personas
                        </button>

                        {/* View Instruction Button */}
                        <button 
                            onClick={() => alert(`System Instruction for ${activePersona.name}:\n\n${systemInstruction}`)}
                            className="flex items-center text-sm font-semibold bg-gray-200 text-gray-700 px-3 py-2 rounded-lg hover:bg-gray-300 transition shadow-md"
                        >
                            <BookOpen className="w-4 h-4 mr-2" />
                            View Instruction
                        </button>
                    </div>
                </div>
                
                <hr className="border-gray-200" />

                {/* Other Settings Grid */}
                <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                    {/* Voice Selection Dropdown */}
                    <div className="flex flex-col">
                        <label htmlFor="voice-select" className="text-sm font-bold text-indigo-800 mb-1">Voice Selection</label>
                        <select
                            id="voice-select"
                            value={ttsVoice}
                            onChange={(e) => setTtsVoice(e.target.value)}
                            className="p-2 rounded-lg text-sm bg-gray-50 border border-gray-300 focus:ring-indigo-500 focus:border-indigo-500 cursor-pointer transition"
                            disabled={isSending}
                        >
                            {VOICE_OPTIONS.map(option => (
                                <option key={option.value} value={option.value}>{option.name}</option>
                            ))}
                        </select>
                    </div>

                    {/* Start New Chat Button */}
                    <div className="flex flex-col justify-end">
                        <button 
                            onClick={handleClearHistory}
                            disabled={isClearing || history.length === 0}
                            className={`p-2 rounded-lg text-white font-semibold transition-colors shadow-md flex items-center justify-center
                                ${isClearing || history.length === 0 
                                    ? 'bg-gray-400 cursor-not-allowed' 
                                    : 'bg-red-500 hover:bg-red-600 active:scale-[.99]'}`}
                            title="Clear all messages in the current conversation thread"
                        >
                            {isClearing ? (
                                <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                            ) : (
                                <RotateCcw className="w-4 h-4 mr-2" />
                            )}
                            {isClearing ? 'Clearing...' : 'Start New Chat'}
                        </button>
                    </div>

                    {/* Structured Output Toggle */}
                    <div className="flex flex-col">
                        <label className="text-sm font-bold text-indigo-800 mb-1">JSON Structured Output</label>
                        <div className="flex items-center justify-between p-2 border border-purple-300 rounded-lg bg-white shadow-sm">
                            <span className={`text-sm font-medium ${isStructured ? 'text-purple-700' : 'text-gray-500'}`}>
                                {isStructured ? 'JSON Mode ACTIVE' : 'JSON Mode Disabled'}
                            </span>
                            <label className="relative inline-block w-12 h-6 cursor-pointer ml-3">
                                <input 
                                    type="checkbox" 
                                    checked={isStructured} 
                                    onChange={() => setIsStructured(prev => !prev)} 
                                    className="sr-only peer"
                                />
                                <span className="absolute inset-0 rounded-full bg-gray-300 peer-checked:bg-purple-600 transition duration-300"></span>
                                <span className="absolute left-1 top-1 h-4 w-4 rounded-full bg-white transition duration-300 peer-checked:translate-x-6"></span>
                            </label>
                        </div>
                    </div>
                </div>

                {/* JSON Schema Definition */}
                <div className={`${isStructured ? 'block' : 'hidden'} sm:col-span-3`}>
                    <label htmlFor="json-schema-input" className="block text-sm font-bold text-purple-800 mb-1 mt-2">
                        JSON Schema Definition
                    </label>
                    <textarea 
                        id="json-schema-input"
                        rows="4"
                        value={jsonSchema}
                        onChange={(e) => setJsonSchema(e.target.value)}
                        className="w-full p-2 border border-purple-300 rounded-lg font-mono text-xs focus:ring-purple-500 focus:border-purple-500 shadow-inner bg-purple-50"
                        placeholder='{"type": "ARRAY", "items": {"type": "OBJECT", ...}}'
                    />
                </div>
                
                {/* Tool Status */}
                <div className="mt-4 p-3 bg-blue-100 rounded-lg flex items-center shadow-sm border border-blue-300 sm:col-span-3">
                    <Calculator className="w-5 h-5 mr-3 text-blue-600 flex-shrink-0" />
                    <p className="text-sm text-blue-800 font-medium">
                        The **Calculator Tool** is active. The AI will use it for high-precision math tasks, regardless of persona.
                    </p>
                </div>
            </div>
        </div>
      </div>


      {/* Chat History Area */}
      <div className="flex-grow overflow-y-auto p-4 space-y-4 max-h-[calc(100vh-160px)] custom-scrollbar">
        {history.length === 0 && (
          <div className="text-center py-10 text-gray-500">
            <p className="text-lg mb-2">Welcome! How can I help you today?</p>
            <p className="text-sm">Active Persona: <span className='font-semibold text-indigo-500'>{activePersona.name}</span>. Go to Settings to change it!</p>
          </div>
        )}
        
        {history.map((msg) => (
          <ChatMessage 
            key={msg.id} 
            message={msg} 
            onSpeak={speakResponse}
            ttsVoice={ttsVoice}
            activePersona={activePersona} 
            onSaveNote={handleSaveNote}
            isLastAiMessage={msg.id === lastAiMessageId} // Pass comparison
            onEmpathyFeedback={handleEmpathyFeedback} // Pass handler
          />
        ))}

        {isSending && (
          <div className="flex justify-start">
            <div className="bg-white text-gray-800 rounded-xl rounded-tl-none p-3 shadow-md border border-gray-100 flex items-center">
              <Loader2 className="w-4 h-4 mr-2 animate-spin text-indigo-500" />
              <p className="text-sm">Assistant is typing...</p>
            </div>
          </div>
        )}

        <div ref={chatEndRef} />
      </div>

      {/* Input Form */}
      <div className="sticky bottom-0 bg-white p-4 border-t border-gray-200 shadow-2xl z-10">
        
        {apiError && (
          <div className="mb-3 p-3 bg-red-100 border border-red-400 text-red-700 rounded-lg text-sm font-medium">
            <p className="font-bold">Status/Error:</p>
            <p>{apiError}</p>
          </div>
        )}
        
        {imagePreviewUrl && (
          <div className="mb-3 p-3 border border-gray-300 rounded-lg flex items-center justify-between bg-gray-50">
            <div className="flex items-center space-x-3 truncate">
                <img src={imagePreviewUrl} alt="Image Preview" className="w-10 h-10 object-cover rounded" />
                <span className="text-sm text-gray-700 truncate">{imageFile.name} attached.</span>
            </div>
            <button
              type="button" onClick={clearImage}
              className="p-1 rounded-full text-gray-500 hover:bg-gray-200"
              aria-label="Remove image"
            >
              <X className="w-4 h-4" />
            </button>
          </div>
        )}

        <form onSubmit={handleSendMessage} className="flex items-center gap-2">
          
          <label htmlFor="image-upload" 
            className={`p-3 rounded-full transition duration-150 cursor-pointer shadow-md
                ${isSending ? 'bg-gray-300 text-gray-500' : 'bg-white text-indigo-600 hover:bg-indigo-50'}`}
            title="Upload Image"
          >
            <ImageIcon className="w-5 h-5" />
            <input
              id="image-upload" ref={fileInputRef} type="file" accept="image/*"
              onChange={handleImageChange} disabled={isSending} className="hidden"
            />
          </label>

          <input
            type="text" value={inputMessage}
            onChange={(e) => setInputMessage(e.target.value)}
            disabled={isSending || !isAuthReady}
            placeholder={isAuthReady ? `Chatting as: ${activePersona.name} (${activePersona.empathyScore}/10 Empathy)` : "Loading memory... (Try refreshing)"}
            className="flex-grow p-3 border border-gray-300 rounded-full focus:ring-indigo-500 focus:border-indigo-500 transition duration-150 shadow-inner disabled:bg-gray-100"
          />
          <button
            type="submit"
            disabled={isSending || (!inputMessage.trim() && !imageFile)}
            className={`p-3 rounded-full text-white transition duration-200 shadow-lg
              ${isSending || (!inputMessage.trim() && !imageFile)
                ? 'bg-indigo-300 cursor-not-allowed'
                : 'bg-indigo-600 hover:bg-indigo-700 active:scale-95'
              }`}
            title="Send Message"
          >
            {isSending ? (
              <Loader2 className="w-5 h-5 animate-spin" />
            ) : (
              <CornerDownLeft className="w-5 h-5" />
            )}
          </button>
        </form>
      </div>
    </div>
  );
};

export default App;
